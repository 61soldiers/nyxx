Index: nyxx/lib/src/core/guild/Guild.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- nyxx/lib/src/core/guild/Guild.dart	(revision c17657e7566a5f411077c568f61ea18dcb1bdb5a)
+++ nyxx/lib/src/core/guild/Guild.dart	(date 1588628776000)
@@ -1,295 +1,16 @@
 part of nyxx;
 
-/// [Guild] object represents single `Discord Server`.
-/// Guilds are a collection of members, channels, and roles that represents one community.
-///
-/// ---------
-///
-/// [channels] property is Map of [Channel]s but it can be cast to specific Channel subclasses. Example with getting all [TextChannel]s in [Guild]:
-/// ```
-/// var textChannels = channels.where((channel) => channel is MessageChannel) as List<TextChannel>;
-/// ```
-/// If you want to get [icon] or [splash] of [Guild] use `iconURL()` method - [icon] property returns only hash, same as [splash] property.
-class Guild extends SnowflakeEntity implements Disposable {
+class DataGuild extends SnowflakeEntity {
   Nyxx client;
 
-  /// The guild's name.
-  late final String name;
-
-  /// The guild's icon hash.
-  late String? icon;
-
-  /// Splash hash
-  late String? splash;
-
-  /// Discovery splash hash
-  late String? discoverySplash;
-
-  /// System channel where system messages are sent
-  late final TextChannel? systemChannel;
-
-  /// enabled guild features
-  late final List<String> features;
-
-  /// The guild's afk channel ID, null if not set.
-  late VoiceChannel? afkChannel;
-
-  /// The guild's voice region.
-  late String region;
-
-  /// The channel ID for the guild's widget if enabled.
-  late final GuildChannel? embedChannel;
-
-  /// The guild's AFK timeout.
-  late final int afkTimeout;
-
-  /// The guild's verification level.
-  late final int verificationLevel;
-
-  /// The guild's notification level.
-  late final int notificationLevel;
-
-  /// The guild's MFA level.
-  late final int mfaLevel;
-
-  /// If the guild's widget is enabled.
-  late final bool? embedEnabled;
-
-  /// Whether or not the guild is available.
-  late final bool available;
-
-  /// System Channel Flags
-  late final int systemChannelFlags;
-
-  /// Channel where "PUBLIC" guilds display rules and/or guidelines
-  late final GuildChannel? rulesChannel;
-
-  /// The guild owner's ID
-  late final User? owner;
-
-  /// The guild's members.
-  late final Cache<Snowflake, Member> members;
-
-  /// The guild's channels.
-  late final ChannelCache channels;
-
-  /// The guild's roles.
-  late final Cache<Snowflake, Role> roles;
-
-  /// Guild custom emojis
-  late final Cache<Snowflake, GuildEmoji> emojis;
-
-  /// Boost level of guild
-  late final PremiumTier premiumTier;
-
-  /// The number of boosts this server currently has
-  late final int? premiumSubscriptionCount;
-
-  /// the preferred locale of a "PUBLIC" guild used
-  /// in server discovery and notices from Discord; defaults to "en-US"
-  late final String preferredLocale;
-
-  /// the id of the channel where admins and moderators
-  /// of "PUBLIC" guilds receive notices from Discord
-  late final GuildChannel? publicUpdatesChannel;
-
-  /// Permission of current(bot) user in this guild
-  Permissions? currentUserPermissions;
-
-  /// Users state cache
-  late final Cache<Snowflake, VoiceState> voiceStates;
-
-  /// Returns url to this guild.
-  String get url => "https://discordapp.com/channels/${this.id.toString()}";
-
-  Role get everyoneRole =>
-      roles.values.firstWhere((r) => r.name == "@everyone");
-
-  /// Returns member object for bot user
-  Member? get selfMember => members[client.self.id];
-
-  /// Upload limit for this guild in bytes
-  int get fileUploadLimit {
-    var megabyte = 1024 * 1024;
-
-    if(this.premiumTier == PremiumTier.tier2) {
-      return 50 * megabyte;
-    }
-
-    if(this.premiumTier == PremiumTier.tier3) {
-      return 100 * megabyte;
-    }
-
-    return 8 * megabyte;
-  }
-
-  Guild._new(this.client, Map<String, dynamic> raw,
-      [this.available = true, bool guildCreate = false])
-      : super(Snowflake(raw['id'] as String)) {
-    if (!this.available) return;
-
-    this.name = raw['name'] as String;
-    this.region = raw['region'] as String;
-    this.afkTimeout = raw['afk_timeout'] as int;
-    this.mfaLevel = raw['mfa_level'] as int;
-    this.verificationLevel = raw['verification_level'] as int;
-    this.notificationLevel = raw['default_message_notifications'] as int;
-
-    this.icon = raw['icon'] as String?;
-    this.discoverySplash = raw['discoverySplash'] as String?;
-    this.splash = raw['splash'] as String?;
-    this.embedEnabled = raw['embed_enabled'] as bool?;
-
-    this.channels = ChannelCache._new();
-
-    if (raw['roles'] != null) {
-      this.roles = _SnowflakeCache<Role>();
-      raw['roles'].forEach((o) {
-        var role = Role._new(o as Map<String, dynamic>, this, client);
-        this.roles[role.id] = role;
-      });
-    }
-
-    this.emojis = _SnowflakeCache();
-    if (raw['emojis'] != null) {
-      raw['emojis'].forEach((dynamic o) {
-        var emoji = GuildEmoji._new(o as Map<String, dynamic>, this, client);
-        this.emojis[emoji.id] = emoji;
-      });
-    }
-
-    if (raw.containsKey('embed_channel_id'))
-      this.embedChannel =
-          client.channels[Snowflake(raw['embed_channel_id'] as String)]
-              as GuildChannel;
-
-    if (raw['system_channel_id'] != null) {
-      var snow = Snowflake(raw['system_channel_id'] as String);
-      if (this.channels.hasKey(snow))
-        this.systemChannel = this.channels[snow] as TextChannel;
-    }
-
-    this.features = (raw['features'] as List<dynamic>).cast<String>();
-
-    if (raw['permissions'] != null) {
-      this.currentUserPermissions =
-          Permissions.fromInt(raw['permissions'] as int);
-    }
-
-    if (raw['afk_channel_id'] != null) {
-      var snow = Snowflake(raw['afk_channel_id'] as String);
-      if (this.channels.hasKey(snow))
-        this.afkChannel = this.channels[snow] as VoiceChannel;
-    }
-
-    this.systemChannelFlags = raw['system_channel_flags'] as int;
-    this.premiumTier = PremiumTier.from(raw['premium_tier'] as int);
-    this.premiumSubscriptionCount = raw['premium_subscription_count'] as int?;
-    this.preferredLocale =  raw['preferred_locale'] as String;
-
-    this.members = _SnowflakeCache();
-
-    if (!guildCreate) return;
-
-    raw['channels'].forEach((o) {
-      late GuildChannel channel;
-
-      if (o['type'] == 0 || o['type'] == 5 || o['type'] == 6)
-        channel = TextChannel._new(o as Map<String, dynamic>, this, client);
-      else if (o['type'] == 2)
-        channel = VoiceChannel._new(o as Map<String, dynamic>, this, client);
-      else if (o['type'] == 4)
-        channel = CategoryChannel._new(o as Map<String, dynamic>, this, client);
-
-      this.channels[channel.id] = channel;
-      client.channels[channel.id] = channel;
-    });
-
-    if (client._options.cacheMembers) {
-      raw['members'].forEach((o) {
-        final member = Member._standard(o as Map<String, dynamic>, this, client);
-        this.members[member.id] = member;
-        client.users[member.id] = member;
-      });
-    }
-
-    raw['presences'].forEach((o) {
-      var member = this.members[Snowflake(o['user']['id'] as String)];
-      if (member != null) {
-        member.status = ClientStatus._deserialize(o['client_status'] as Map<String, dynamic>);
-
-        if (o['game'] != null) {
-          member.presence = Activity._new(o['game'] as Map<String, dynamic>);
-        }
-      }
-    });
-
-    this.owner = this.members[Snowflake(raw['owner_id'] as String)];
-
-    this.voiceStates = _SnowflakeCache();
-    if (raw['voice_states'] != null) {
-      raw['voice_states'].forEach((o) {
-        var state = VoiceState._new(o as Map<String, dynamic>, client, this);
-
-        if (state.user != null)
-          this.voiceStates[state.user!.id] = state;
-      });
-    }
-
-    if(raw['rules_channel_id'] != null) {
-      this.rulesChannel = this.channels[Snowflake(raw['rules_channel_id'])] as GuildChannel?;
-    }
-
-    if(raw['public_updates_channel_id'] != null) {
-      this.publicUpdatesChannel = this.channels[Snowflake(raw['public_updates_channel_id'])] as GuildChannel?;
-    }
-  }
-
-  /// The guild's icon, represented as URL.
-  /// If guild doesn't have icon it returns null.
-  String? iconURL({String format = 'webp', int size = 128}) {
-    if (this.icon != null)
-      return 'https://cdn.${_Constants.cdnHost}/icons/${this.id}/${this.icon}.$format?size=$size';
-
-    return null;
-  }
-
-  /// URL to guild's splash.
-  /// If guild doesn't have splash it returns null.
-  String? splashURL({String format = 'webp', int size = 128}) {
-    if (this.splash != null)
-      return 'https://cdn.${_Constants.cdnHost}/splashes/${this.id}/${this.splash}.$format?size=$size';
-
-    return null;
-  }
-
-  /// URL to guild's splash.
-  /// If guild doesn't have splash it returns null.
-  String? discoveryURL({String format = 'webp', int size = 128}) {
-    if (this.splash != null)
-      return 'https://cdn.${_Constants.cdnHost}/discovery-splashes/${this.id}/${this.splash}.$format?size=$size';
-
-    return null;
-  }
-
-  /// Allows to download [Guild] widget aka advert png
-  /// Possible options for [style]: shield (default), banner1, banner2, banner3, banner4
-  String guildWidgetUrl([String style = "shield"]) {
-    return "http://cdn.${_Constants.cdnHost}/guilds/${this.id.toString()}/widget.png?style=${style}";
-  }
-
-  /// Returns a string representation of this object - Guild name.
-  @override
-  String toString() => this.name;
+  DataGuild._new(Snowflake id, this.client) : super(id);
 
   /// Gets Guild Emoji based on Id
   ///
   /// ```
   /// var emoji = await guild.getEmoji(Snowflake("461449676218957824"));
   /// ```
-  Future<GuildEmoji> getEmoji(Snowflake emojiId, [bool useCache = true]) async {
-    if (emojis.hasKey(emojiId) && useCache) return emojis[emojiId] as GuildEmoji;
-
+  Future<GuildEmoji> fetchEmoji(Snowflake emojiId, [bool useCache = true]) async {
     var response = await client._http._execute(
         BasicRequest._new("/guilds/$id/emojis/${emojiId.toString()}"));
 
@@ -336,11 +57,12 @@
     return Future.error(response);
   }
 
+  // TODO: `include_roles parameter`
   /// Returns [int] indicating the number of members that would be removed in a prune operation.
   Future<int> pruneCount(int days) async {
     var response = await client._http._execute(
-        BasicRequest._new("/guilds/$id/prune", body: {
-          "days": days
+        BasicRequest._new("/guilds/$id/prune", queryParams: {
+          "days": days.toString()
         }));
 
     if(response is HttpResponseSuccess) {
@@ -415,26 +137,6 @@
         BasicRequest._new("/users/@me/guilds/$id", method: "DELETE"));
   }
 
-  Future<Invite> createInvite(
-      {int maxAge = 0,
-      int maxUses = 0,
-      bool temporary = false,
-      bool unique = false,
-      String? auditReason}) async {
-    var chan = this.channels.first as GuildChannel?;
-
-    if (chan == null) {
-      return Future.error("Cannot get any channel to create invite to");
-    }
-
-    return chan.createInvite(
-        maxUses: maxUses,
-        maxAge: maxAge,
-        temporary: temporary,
-        unique: unique,
-        auditReason: auditReason);
-  }
-
   /// Returns list of Guilds invites
   Stream<Invite> getGuildInvites() async* {
     var response = await client._http._execute(BasicRequest._new( "/guilds/$id/invites"));
@@ -456,9 +158,9 @@
   /// ```
   Future<AuditLog> getAuditLogs(
       {Snowflake? userId,
-      int? actionType,
-      Snowflake? before,
-      int? limit}) async {
+        int? actionType,
+        Snowflake? before,
+        int? limit}) async {
     var queryParams = <String, String> {
       if (userId != null) 'user_id' : userId.toString(),
       if (actionType != null) 'action_type' : actionType.toString(),
@@ -559,12 +261,12 @@
   /// ```
   Future<GuildChannel> createChannel(String name, ChannelType type,
       {int? bitrate,
-      String? topic,
-      CategoryChannel? parent,
-      bool? nsfw,
-      int? userLimit,
-      PermissionsBuilder? permissions,
-      String? auditReason}) async {
+        String? topic,
+        CategoryChannel? parent,
+        bool? nsfw,
+        int? userLimit,
+        PermissionsBuilder? permissions,
+        String? auditReason}) async {
     // Checks to avoid API panic
     if (type == ChannelType.dm || type == ChannelType.groupDm) {
       return Future.error("Cannot create DM channel.");
@@ -665,12 +367,12 @@
   /// Edits the guild.
   Future<Guild> edit(
       {String? name,
-      int? verificationLevel,
-      int? notificationLevel,
-      VoiceChannel? afkChannel,
-      int? afkTimeout,
-      String? icon,
-      String? auditReason}) async {
+        int? verificationLevel,
+        int? notificationLevel,
+        VoiceChannel? afkChannel,
+        int? afkTimeout,
+        String? icon,
+        String? auditReason}) async {
     var body = <String, dynamic> {
       if(name != null) "name" : name,
       if(verificationLevel != null) "verification_level" : verificationLevel,
@@ -691,21 +393,12 @@
     return Future.error(response);
   }
 
-  /// Gets a [Member] object. Caches fetched member if not cached.
-  ///
-  /// ```
-  /// var member = guild.getMember(user);
-  /// ```
-  Future<Member> getMember(User user) async => getMemberById(user.id);
-
-  /// Gets a [Member] object by id. Caches fetched member if not cached.
+  /// Gets a [Member] object by id.
   ///
   /// ```
   /// var member = guild.getMember(Snowflake('302359795648954380'));
   /// ```
-  Future<Member> getMemberById(Snowflake id) async {
-    if (this.members.hasKey(id)) return this.members[id] as Member;
-
+  Future<Member> fetchMemberById(Snowflake id) async {
     var response = await client._http._execute(
         BasicRequest._new('/guilds/${this.id}/members/${id.toString()}'));
 
@@ -716,6 +409,22 @@
     return Future.error(response);
   }
 
+  /// Returns a [Stream] of [Member] objects whose username or nickname starts with a provided string.
+  /// By default limits to one entry - can be changed with [limit] parameter.
+  Stream<Member> searchMembers(String query, {int limit = 1}) async* {
+    var response = await client._http._execute(
+        BasicRequest._new("/guilds/${this.id}/members/search",
+            queryParams: { "query" : query, "limit": limit.toString() }));
+
+    if(response is HttpResponseError) {
+      yield* Stream.error(response);
+    }
+
+    for(Map<String, dynamic> member in (response as HttpResponseSuccess).jsonBody) {
+      yield Member._standard(member, this, client);
+    }
+  }
+
   /// Gets all of the webhooks for this channel.
   Stream<Webhook> getWebhooks() async* {
     var response = await client._http._execute(
@@ -736,6 +445,351 @@
         BasicRequest._new("/guilds/${this.id}", method: "DELETE"));
   }
 
+}
+
+/// [Guild] object represents single `Discord Server`.
+/// Guilds are a collection of members, channels, and roles that represents one community.
+///
+/// ---------
+///
+/// [channels] property is Map of [Channel]s but it can be cast to specific Channel subclasses. Example with getting all [TextChannel]s in [Guild]:
+/// ```
+/// var textChannels = channels.where((channel) => channel is MessageChannel) as List<TextChannel>;
+/// ```
+/// If you want to get [icon] or [splash] of [Guild] use `iconURL()` method - [icon] property returns only hash, same as [splash] property.
+class Guild extends DataGuild implements Disposable {
+  /// The guild's name.
+  late final String name;
+
+  /// The guild's icon hash.
+  late String? icon;
+
+  /// Splash hash
+  late String? splash;
+
+  /// Discovery splash hash
+  late String? discoverySplash;
+
+  /// System channel where system messages are sent
+  late final TextChannel? systemChannel;
+
+  /// enabled guild features
+  late final List<String> features;
+
+  /// The guild's afk channel ID, null if not set.
+  late VoiceChannel? afkChannel;
+
+  /// The guild's voice region.
+  late String region;
+
+  /// The channel ID for the guild's widget if enabled.
+  late final GuildChannel? embedChannel;
+
+  /// The guild's AFK timeout.
+  late final int afkTimeout;
+
+  /// The guild's verification level.
+  late final int verificationLevel;
+
+  /// The guild's notification level.
+  late final int notificationLevel;
+
+  /// The guild's MFA level.
+  late final int mfaLevel;
+
+  /// If the guild's widget is enabled.
+  late final bool? embedEnabled;
+
+  /// Whether or not the guild is available.
+  late final bool available;
+
+  /// System Channel Flags
+  late final int systemChannelFlags;
+
+  /// Channel where "PUBLIC" guilds display rules and/or guidelines
+  late final GuildChannel? rulesChannel;
+
+  /// The guild owner's ID
+  late final User? owner;
+
+  /// The guild's members.
+  late final Cache<Snowflake, Member> members;
+
+  /// The guild's channels.
+  late final ChannelCache channels;
+
+  /// The guild's roles.
+  late final Cache<Snowflake, Role> roles;
+
+  /// Guild custom emojis
+  late final Cache<Snowflake, GuildEmoji> emojis;
+
+  /// Boost level of guild
+  late final PremiumTier premiumTier;
+
+  /// The number of boosts this server currently has
+  late final int? premiumSubscriptionCount;
+
+  /// the preferred locale of a "PUBLIC" guild used
+  /// in server discovery and notices from Discord; defaults to "en-US"
+  late final String preferredLocale;
+
+  /// the id of the channel where admins and moderators
+  /// of "PUBLIC" guilds receive notices from Discord
+  late final GuildChannel? publicUpdatesChannel;
+
+  /// Permission of current(bot) user in this guild
+  Permissions? currentUserPermissions;
+
+  /// Users state cache
+  late final Cache<Snowflake, VoiceState> voiceStates;
+
+  /// Returns url to this guild.
+  String get url => "https://discordapp.com/channels/${this.id.toString()}";
+
+  Role get everyoneRole =>
+      roles.values.firstWhere((r) => r.name == "@everyone");
+
+  /// Returns member object for bot user
+  Member? get selfMember => members[client.self.id];
+
+  /// Upload limit for this guild in bytes
+  int get fileUploadLimit {
+    var megabyte = 1024 * 1024;
+
+    if(this.premiumTier == PremiumTier.tier2) {
+      return 50 * megabyte;
+    }
+
+    if(this.premiumTier == PremiumTier.tier3) {
+      return 100 * megabyte;
+    }
+
+    return 8 * megabyte;
+  }
+
+  Guild._new(Nyxx client, Map<String, dynamic> raw,
+      [this.available = true, bool guildCreate = false])
+      : super._new(Snowflake(raw['id']), client) {
+    if (!this.available) return;
+
+    this.name = raw['name'] as String;
+    this.region = raw['region'] as String;
+    this.afkTimeout = raw['afk_timeout'] as int;
+    this.mfaLevel = raw['mfa_level'] as int;
+    this.verificationLevel = raw['verification_level'] as int;
+    this.notificationLevel = raw['default_message_notifications'] as int;
+
+    this.icon = raw['icon'] as String?;
+    this.discoverySplash = raw['discoverySplash'] as String?;
+    this.splash = raw['splash'] as String?;
+    this.embedEnabled = raw['embed_enabled'] as bool?;
+
+    this.channels = ChannelCache._new();
+
+    if (raw['roles'] != null) {
+      this.roles = _SnowflakeCache<Role>();
+      raw['roles'].forEach((o) {
+        var role = Role._new(o as Map<String, dynamic>, this, client);
+        this.roles[role.id] = role;
+      });
+    }
+
+    this.emojis = _SnowflakeCache();
+    if (raw['emojis'] != null) {
+      raw['emojis'].forEach((dynamic o) {
+        var emoji = GuildEmoji._new(o as Map<String, dynamic>, this, client);
+        this.emojis[emoji.id] = emoji;
+      });
+    }
+
+    if (raw.containsKey('embed_channel_id'))
+      this.embedChannel =
+          client.channels[Snowflake(raw['embed_channel_id'] as String)]
+              as GuildChannel;
+
+    if (raw['system_channel_id'] != null) {
+      var snow = Snowflake(raw['system_channel_id'] as String);
+      if (this.channels.hasKey(snow))
+        this.systemChannel = this.channels[snow] as TextChannel;
+    }
+
+    this.features = (raw['features'] as List<dynamic>).cast<String>();
+
+    if (raw['permissions'] != null) {
+      this.currentUserPermissions =
+          Permissions.fromInt(raw['permissions'] as int);
+    }
+
+    if (raw['afk_channel_id'] != null) {
+      var snow = Snowflake(raw['afk_channel_id'] as String);
+      if (this.channels.hasKey(snow))
+        this.afkChannel = this.channels[snow] as VoiceChannel;
+    }
+
+    this.systemChannelFlags = raw['system_channel_flags'] as int;
+    this.premiumTier = PremiumTier.from(raw['premium_tier'] as int);
+    this.premiumSubscriptionCount = raw['premium_subscription_count'] as int?;
+    this.preferredLocale =  raw['preferred_locale'] as String;
+
+    this.members = _SnowflakeCache();
+
+    if (!guildCreate) return;
+
+    raw['channels'].forEach((o) {
+      late GuildChannel channel;
+
+      if (o['type'] == 0 || o['type'] == 5 || o['type'] == 6)
+        channel = TextChannel._new(o as Map<String, dynamic>, this, client);
+      else if (o['type'] == 2)
+        channel = VoiceChannel._new(o as Map<String, dynamic>, this, client);
+      else if (o['type'] == 4)
+        channel = CategoryChannel._new(o as Map<String, dynamic>, this, client);
+
+      this.channels[channel.id] = channel;
+      client.channels[channel.id] = channel;
+    });
+
+    if (client._options.cacheMembers) {
+      raw['members'].forEach((o) {
+        final member = Member._standard(o as Map<String, dynamic>, this, client);
+        this.members[member.id] = member;
+        client.users[member.id] = member;
+      });
+    }
+
+    raw['presences'].forEach((o) {
+      var member = this.members[Snowflake(o['user']['id'] as String)];
+      if (member != null) {
+        member.status = ClientStatus._deserialize(o['client_status'] as Map<String, dynamic>);
+
+        if (o['game'] != null) {
+          member.presence = Activity._new(o['game'] as Map<String, dynamic>);
+        }
+      }
+    });
+
+    this.owner = this.members[Snowflake(raw['owner_id'] as String)];
+
+    this.voiceStates = _SnowflakeCache();
+    if (raw['voice_states'] != null) {
+      raw['voice_states'].forEach((o) {
+        var state = VoiceState._new(o as Map<String, dynamic>, client, this);
+
+        if (state.user != null)
+          this.voiceStates[state.user!.id] = state;
+      });
+    }
+
+    if(raw['rules_channel_id'] != null) {
+      this.rulesChannel = this.channels[Snowflake(raw['rules_channel_id'])] as GuildChannel?;
+    }
+
+    if(raw['public_updates_channel_id'] != null) {
+      this.publicUpdatesChannel = this.channels[Snowflake(raw['public_updates_channel_id'])] as GuildChannel?;
+    }
+  }
+
+  /// The guild's icon, represented as URL.
+  /// If guild doesn't have icon it returns null.
+  String? iconURL({String format = 'webp', int size = 128}) {
+    if (this.icon != null)
+      return 'https://cdn.${_Constants.cdnHost}/icons/${this.id}/${this.icon}.$format?size=$size';
+
+    return null;
+  }
+
+  /// URL to guild's splash.
+  /// If guild doesn't have splash it returns null.
+  String? splashURL({String format = 'webp', int size = 128}) {
+    if (this.splash != null)
+      return 'https://cdn.${_Constants.cdnHost}/splashes/${this.id}/${this.splash}.$format?size=$size';
+
+    return null;
+  }
+
+  /// URL to guild's splash.
+  /// If guild doesn't have splash it returns null.
+  String? discoveryURL({String format = 'webp', int size = 128}) {
+    if (this.splash != null)
+      return 'https://cdn.${_Constants.cdnHost}/discovery-splashes/${this.id}/${this.splash}.$format?size=$size';
+
+    return null;
+  }
+
+  /// Allows to download [Guild] widget aka advert png
+  /// Possible options for [style]: shield (default), banner1, banner2, banner3, banner4
+  String guildWidgetUrl([String style = "shield"]) {
+    return "http://cdn.${_Constants.cdnHost}/guilds/${this.id.toString()}/widget.png?style=${style}";
+  }
+
+  /// Returns a string representation of this object - Guild name.
+  @override
+  String toString() => this.name;
+
+  /// Gets Guild Emoji based on Id
+  ///
+  /// ```
+  /// var emoji = await guild.getEmoji(Snowflake("461449676218957824"));
+  /// ```
+  Future<GuildEmoji> getEmoji(Snowflake emojiId, [bool useCache = true]) async {
+    if (emojis.hasKey(emojiId) && useCache) return emojis[emojiId] as GuildEmoji;
+
+    var response = await client._http._execute(
+        BasicRequest._new("/guilds/$id/emojis/${emojiId.toString()}"));
+
+    if(response is HttpResponseSuccess) {
+      return GuildEmoji._new(response.jsonBody as Map<String, dynamic>, this, client);
+    }
+
+    return Future.error(response);
+  }
+
+  Future<Invite> createInvite(
+      {int maxAge = 0,
+      int maxUses = 0,
+      bool temporary = false,
+      bool unique = false,
+      String? auditReason}) async {
+    var chan = this.channels.first as GuildChannel?;
+
+    if (chan == null) {
+      return Future.error("Cannot get any channel to create invite to");
+    }
+
+    return chan.createInvite(
+        maxUses: maxUses,
+        maxAge: maxAge,
+        temporary: temporary,
+        unique: unique,
+        auditReason: auditReason);
+  }
+
+  /// Gets a [Member] object. Caches fetched member if not cached.
+  ///
+  /// ```
+  /// var member = guild.getMember(user);
+  /// ```
+  Future<Member> getMember(User user) async => getMemberById(user.id);
+
+  /// Gets a [Member] object by id. Caches fetched member if not cached.
+  ///
+  /// ```
+  /// var member = guild.getMember(Snowflake('302359795648954380'));
+  /// ```
+  Future<Member> getMemberById(Snowflake id) async {
+    if (this.members.hasKey(id)) return this.members[id] as Member;
+
+    var response = await client._http._execute(
+        BasicRequest._new('/guilds/${this.id}/members/${id.toString()}'));
+
+    if(response is HttpResponseSuccess) {
+      return Member._standard(response.jsonBody as Map<String, dynamic>, this, client);
+    }
+
+    return Future.error(response);
+  }
+
   @override
   Future<void> dispose() async {
     await channels.dispose();
Index: nyxx/lib/src/core/message/GuildEmoji.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- nyxx/lib/src/core/message/GuildEmoji.dart	(revision c17657e7566a5f411077c568f61ea18dcb1bdb5a)
+++ nyxx/lib/src/core/message/GuildEmoji.dart	(date 1588628915000)
@@ -9,7 +9,7 @@
   @override
 
   /// Emoji guild
-  late final Guild guild;
+  late final DataGuild guild;
 
   @override
 
@@ -43,9 +43,9 @@
     this.animated = raw['animated'] as bool? ?? false;
 
     this.roles = [];
-    if (raw['roles'] != null) {
+    if (raw['roles'] != null && this.guild is Guild) {
       raw['roles'].forEach(
-          (o) => this.roles.add(this.guild.roles[Snowflake(o as String)]));
+          (o) => this.roles.add((this.guild as Guild).roles[Snowflake(o as String)]));
     }
 
     this.partial = false;
Index: nyxx/lib/src/core/GuildEntity.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- nyxx/lib/src/core/GuildEntity.dart	(revision c17657e7566a5f411077c568f61ea18dcb1bdb5a)
+++ nyxx/lib/src/core/GuildEntity.dart	(date 1588628915000)
@@ -2,5 +2,5 @@
 
 /// Represents entity which bound to guild, eg. member, emoji, message, role.
 abstract class GuildEntity {
-  Guild? get guild;
+  DataGuild? get guild;
 }
